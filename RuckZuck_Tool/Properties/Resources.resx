<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Assembly" xml:space="preserve">
    <value>using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("RuckZuck Package-Wrapper")]
[assembly: AssemblyDescription("Install Software from the RuckZuck.tools Repository")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("RuckZuck.tools")]
[assembly: AssemblyProduct("RZRZRZ")]
[assembly: AssemblyCopyright("Copyright ©  2023 by Roger Zander")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: ComVisible(false)]
[assembly: Guid("2193048a-dcd5-433e-a2c0-28384b9ebad2")]
[assembly: AssemblyVersion("1.7.2.5")]
[assembly: AssemblyFileVersion("1.7.2.5")]</value>
  </data>
  <data name="RZRestApi" xml:space="preserve">
    <value>using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Web.Script.Serialization;

namespace RuckZuck.Base
{
    public class AddSoftware
    {
        public string Architecture { get; set; }
        public string Author { get; set; }
        public string Category { get; set; }
        public string ContentID { get; set; }
        public string Description { get; set; }
        public List&lt;contentFiles&gt; Files { get; set; }
        public string IconHash { get; set; }

        public string IconURL
        {
            get
            {
                //Support new V2 REST API
                if (!string.IsNullOrEmpty(IconHash))
                {
                    return RZRestAPIv2.sURL + "/rest/v2/GetIcon?size=32&amp;iconhash=" + IconHash;
                }

                if (SWId &gt; 0)
                {
                    //IconId = SWId;
                    string sURL = RZRestAPIv2.sURL + "/rest/v2/GetIcon?size=32&amp;iconid=" + SWId.ToString();
                    return sURL;
                }

                return "";
            }
        }

        public byte[] Image { get; set; }
        public string Manufacturer { get; set; }
        public string MSIProductID { get; set; }
        public string[] PreRequisites { get; set; }
        public string ProductName { get; set; }
        public string ProductURL { get; set; }
        public string ProductVersion { get; set; }
        public string PSDetection { get; set; }
        public string PSInstall { get; set; }
        public string PSPostInstall { get; set; }
        public string PSPreInstall { get; set; }
        public string PSPreReq { get; set; }
        public string PSUninstall { get; set; }
        public string ShortName { get; set; }

        //vNext 5.9.2017
        //public long SWId { get { return IconId; } set { IconId = value; } }
        public long SWId { get; set; }

        //public long IconId { get; set; }
        //remove if SWId is in place 5.9.2017
        //public long IconId { get; set; }
    }

    public class contentFiles
    {
        public string FileHash { get; set; }
        public string FileName { get; set; }
        public long FileSize { get; set; }
        public string HashType { get; set; }
        public string URL { get; set; }
    }

    public class DLStatus
    {
        public long DownloadedBytes { get; set; }
        public string Filename { get; set; }

        public int PercentDownloaded { get; set; }
        public long TotalBytes { get; set; }
        public string URL { get; set; }
    }

    public class DLTask
    {
        internal string _status = "";
        public bool AutoInstall { get; set; }
        public long DownloadedBytes { get; set; }
        public bool Downloading { get; set; }
        public bool Error { get; set; }
        public string ErrorMessage { get; set; }
        public List&lt;contentFiles&gt; Files { get; set; }
        public string IconURL { get; set; }

        //public byte[] Image { get; set; }
        public bool Installed { get; set; }

        public bool Installing { get; set; }
        public string Manufacturer { get; set; }
        public int PercentDownloaded { get; set; }
        public string ProductName { get; set; }

        public string ProductVersion { get; set; }
        public string ShortName { get; set; }

        public string Status
        {
            get
            {
                if (string.IsNullOrEmpty(_status))
                {
                    if (Installing &amp;&amp; !Error)
                        return "Installing";
                    if (Downloading &amp;&amp; !Error)
                        return "Downloading";
                    if (Installed &amp;&amp; !Error)
                        return "Installed";
                    if (UnInstalled &amp;&amp; !Error)
                        return "Uninstalled";
                    if (WaitingForDependency)
                        return "Installing dependencies";
                    if (PercentDownloaded == 100 &amp;&amp; !Error)
                        return "Downloaded";
                    if (Error)
                        return ErrorMessage;

                    return "Waiting";
                }
                else
                    return _status;
            }
            set
            {
                _status = value;
            }
        }

        public RZUpdate.SWUpdate SWUpd { get; set; }
        public long TotalBytes { get; set; }
        public bool UnInstalled { get; set; }
        public bool WaitingForDependency { get; set; }
        //public Task task { get; set; }
    }

    public class GetSoftware
    {
        public List&lt;string&gt; Categories { get; set; }
        public string Description { get; set; }
        public Int32? Downloads { get; set; }
        public string IconHash { get; set; }

        public string IconURL
        {
            get
            {
                //Support new V2 REST API
                if (!string.IsNullOrEmpty(IconHash))
                {
                    return RZRestAPIv2.sURL + "/rest/v2/GetIcon?size=32&amp;iconhash=" + IconHash;
                }

                if (SWId &gt; 0)
                {
                    return RZRestAPIv2.sURL + "/rest/GetIcon?size=32&amp;id=" + SWId.ToString();
                }

                return "";
            }
        }

        public bool isInstalled { get; set; }
        public string Manufacturer { get; set; }
        public string ProductName { get; set; }
        public string ProductURL { get; set; }
        public string ProductVersion { get; set; }
        public string ShortName { get; set; }
        public long SWId { get; set; }

        public DateTime? ModifyDate { get; set; }

        public double Age
        {
            get { if (ModifyDate == null) { return -1; } else { return Math.Abs((DateTime.Now - (DateTime)ModifyDate).Days); }; }
        }
    }

    internal class RZRestAPIv2
    {
        public static string CustomerID = "";
        public static bool DisableBroadcast = false;
        private static string _sURL = "UDP";
        private static HttpClient oClient = new HttpClient(); //thx https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/

        public static string sURL
        {
            get
            {
                if (_sURL != "UDP" &amp;&amp; !string.IsNullOrEmpty(_sURL))
                    return _sURL;

                try
                {
                    var vBroadcast = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Policies\RuckZuck", "Broadcast", 1);
                    if ((int)vBroadcast == 0) //only disable if set to 0
                        DisableBroadcast = true;
                }
                catch { }

                if (DisableBroadcast)
                    _sURL = "";

                try
                {
                    string sCustID = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Policies\RuckZuck", "CustomerID", "") as string;
                    if (!string.IsNullOrEmpty(sCustID))
                    {
                        CustomerID = sCustID; //Override CustomerID
                    }
                }
                catch { }

                try
                {
                    string sWebSVC = Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Policies\RuckZuck", "WebService", "") as string;
                    if (!string.IsNullOrEmpty(sWebSVC))
                    {
                        if (sWebSVC.StartsWith("http", StringComparison.CurrentCultureIgnoreCase))
                        {
                            _sURL = sWebSVC.TrimEnd('/');
                        }
                    }
                }
                catch { }

                if (_sURL == "UDP" &amp;&amp; !DisableBroadcast)
                {
                    try
                    {
                        using (var Client = new UdpClient())
                        {
                            Client.Client.SendTimeout = 1000;
                            Client.Client.ReceiveTimeout = 1000;
                            var RequestData = Encoding.ASCII.GetBytes(Environment.MachineName);
                            var ServerEp = new IPEndPoint(IPAddress.Any, 0);

                            Client.EnableBroadcast = true;
                            Client.Send(RequestData, RequestData.Length, new IPEndPoint(IPAddress.Broadcast, 5001));

                            var ServerResponseData = Client.Receive(ref ServerEp);
                            var ServerResponse = Encoding.ASCII.GetString(ServerResponseData);
                            Console.WriteLine("Recived {0} from {1}", ServerResponse, ServerEp.Address.ToString());
                            if (ServerResponse.StartsWith("http"))
                                _sURL = ServerResponse;
                            Client.Close();
                        }
                    }
                    catch { _sURL = ""; }
                }

                if (string.IsNullOrEmpty(_sURL))
                {
                    string tURL = GetURLAsync(CustomerID).Result;
                    _sURL = tURL;
                    return tURL;
                }
                else
                    return _sURL;
            }
            set
            {
                _sURL = value;
            }
        }

        public static async Task&lt;List&lt;AddSoftware&gt;&gt; CheckForUpdateAsync(List&lt;AddSoftware&gt; lSoftware, string customerid = "", CancellationToken? ct = null)
        {
            //System.Web.Script.Serialization version
            try
            {
                if (ct == null)
                    ct = new CancellationTokenSource(90000).Token; //90s TimeOut

                if (lSoftware.Count &gt; 0)
                {
                    if (string.IsNullOrEmpty(customerid))
                        customerid = CustomerID;

                    string sSoftware = GetJsonFromObject(lSoftware);

                    HttpContent oCont = new StringContent(sSoftware, Encoding.UTF8, "application/json");
                    var response = await oClient.PostAsync(sURL + "/rest/v2/checkforupdate?customerid=" + customerid, oCont, (CancellationToken)ct);
                    List&lt;AddSoftware&gt; lRes = GetObjectFromJson&lt;List&lt;AddSoftware&gt;&gt;(await response.Content.ReadAsStringAsync());

                    return lRes;
                }
            }
            catch
            {
                _sURL = ""; //enforce reload endpoint URL
            }

            return new List&lt;AddSoftware&gt;();
        }

        public static string GetJsonFromObject&lt;T&gt;(T JsonObject)
        {
            try
            {
                bool isNewtonsoft = isNewtonsoftLoaded();

                if (isNewtonsoft)
                {
                    return _GetJsonFromObjectNewton(JsonObject); //Newtonsoft
                }
                else
                {
                    JavaScriptSerializer serializer = new JavaScriptSerializer();  //System.Web.Script.Serialization;
                    return FormatJson(serializer.Serialize(JsonObject)); //System.Web.Script.Serialization;
                }
            }
            catch (Exception ex)
            {
                ex.Message.ToString();
            }

            return "";
        }

        private static string _GetJsonFromObjectNewton&lt;T&gt;(T JsonObject)
        {
            try
            {
                //return Newtonsoft.Json.JsonConvert.SerializeObject(JsonObject, Newtonsoft.Json.Formatting.Indented); //Newtonsoft
            }
            catch (Exception ex)
            {
                ex.Message.ToString();
            }

            return "";
        }

        public static T GetObjectFromJson&lt;T&gt;(string JsonObject)
        {
            try
            {
                bool isNewtonsoft = isNewtonsoftLoaded();

                if (isNewtonsoft)
                {
                    return _GetObjectFromJsonNewton&lt;T&gt;(JsonObject); //Newtonsoft
                }
                else
                {
                    JavaScriptSerializer serializer = new JavaScriptSerializer();  //System.Web.Script.Serialization;
                    return serializer.Deserialize&lt;T&gt;(JsonObject); //System.Web.Script.Serialization;
                }
            }
            catch (ReflectionTypeLoadException ex)
            {
                ex.Message.ToString();
            }

            return default(T);
        }

        private static T _GetObjectFromJsonNewton&lt;T&gt;(string JsonObject)
        {
            try
            {
                //return Newtonsoft.Json.JsonConvert.DeserializeObject&lt;T&gt;(JsonObject); //Newtonsoft
            }
            catch (ReflectionTypeLoadException ex)
            {
                ex.Message.ToString();
            }

            return default(T);
        }

        //Check if Newtonsoft.Json is loaded
        public static bool isNewtonsoftLoaded()
        {
            try
            {
                //try to load assembly
                if (Assembly.Load("Newtonsoft.Json") != null)
                    return true;
            }
            catch(Exception ex)
            {
                ex.Message.ToString();
            }

            return false;
        }

        //Source https://stackoverflow.com/questions/5881204/how-to-set-formatting-with-javascriptserializer-when-json-serializing
        public static string FormatJson(string inputText)
        {
            bool escaped = false;
            bool inquotes = false;
            int column = 0;
            int indentation = 0;
            Stack&lt;int&gt; indentations = new Stack&lt;int&gt;();
            int TABBING = 8;
            StringBuilder sb = new StringBuilder();
            foreach (char x in inputText)
            {
                sb.Append(x);
                column++;
                if (escaped)
                {
                    escaped = false;
                }
                else
                {
                    if (x == '\\')
                    {
                        escaped = true;
                    }
                    else if (x == '\"')
                    {
                        inquotes = !inquotes;
                    }
                    else if (!inquotes)
                    {
                        if (x == ',')
                        {
                            // if we see a comma, go to next line, and indent to the same depth
                            sb.Append("\r\n");
                            column = 0;
                            for (int i = 0; i &lt; indentation; i++)
                            {
                                sb.Append(" ");
                                column++;
                            }
                        }
                        else if (x == '[' || x == '{')
                        {
                            // if we open a bracket or brace, indent further (push on stack)
                            indentations.Push(indentation);
                            indentation = column;
                        }
                        else if (x == ']' || x == '}')
                        {
                            // if we close a bracket or brace, undo one level of indent (pop)
                            indentation = indentations.Pop();
                        }
                        else if (x == ':')
                        {
                            // if we see a colon, add spaces until we get to the next
                            // tab stop, but without using tab characters!
                            while ((column % TABBING) != 0)
                            {
                                sb.Append(' ');
                                column++;
                            }
                        }
                    }
                }
            }
            return sb.ToString();
        }

        public static async Task&lt;string&gt; FeedbackAsync(string productName, string productVersion, string manufacturer, string working, string userKey, string feedback, string customerid = "", CancellationToken? ct = null)
        {
            if (!string.IsNullOrEmpty(feedback))
            {
                try
                {
                    if (ct == null)
                        ct = new CancellationTokenSource(30000).Token; //30s TimeOut

                    var oRes = await oClient.GetStringAsync(new Uri(sURL + "/rest/v2/feedback?name=" + WebUtility.UrlEncode(productName) + "&amp;ver=" + WebUtility.UrlEncode(productVersion) + "&amp;man=" + WebUtility.UrlEncode(manufacturer) + "&amp;ok=" + working + "&amp;user=" + WebUtility.UrlEncode(userKey) + "&amp;text=" + WebUtility.UrlEncode(feedback) + "&amp;customerid=" + WebUtility.UrlEncode(customerid))); //, (CancellationToken)ct on .NET 6
                    return oRes;
                }
                catch { }
            }

            return "";
        }

        public static async Task&lt;List&lt;GetSoftware&gt;&gt; GetCatalogAsync(string customerid = "", CancellationToken? ct = null)
        {
            if (ct == null)
                ct = new CancellationTokenSource(60000).Token; //60s TimeOut

            if (string.IsNullOrEmpty(customerid))
            {
                customerid = CustomerID;
            }

            if (!customerid.StartsWith("--"))
            {
                if (File.Exists(Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), "rzcat.json"))) //Cached content exists
                {
                    try
                    {
                        DateTime dCreationDate = File.GetLastWriteTime(Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), "rzcat.json"));
                        if ((DateTime.Now - dCreationDate) &lt; new TimeSpan(0, 30, 0)) //Cache for 30min
                        {
                            //return cached Content
                            string jRes = File.ReadAllText(Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), "rzcat.json"));

                            List&lt;GetSoftware&gt; lRes = GetObjectFromJson&lt;List&lt;GetSoftware&gt;&gt;(jRes);

                            return lRes;
                        }
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine("E1" + ex.Message, "GetCatalog");
                    }
                }
            }

            try
            {
                //sURL = "UDP"; //reset URL as this part is only called every 30 min

                string response;
                if (string.IsNullOrEmpty(customerid) || customerid.Count(t =&gt; t == '.') == 3)
                    response = await oClient.GetStringAsync(sURL + "/rest/v2/GetCatalog"); //add cts in .NET 6
                else
                    response = await oClient.GetStringAsync(sURL + "/rest/v2/GetCatalog?customerid=" + customerid); //add cts in .NET 6

                if (!string.IsNullOrEmpty(response) &amp;&amp; !ct.Value.IsCancellationRequested)
                {
                    List&lt;GetSoftware&gt; lRes = GetObjectFromJson&lt;List&lt;GetSoftware&gt;&gt;(response);
                    Console.WriteLine(lRes.Count);
                    if (lRes.Count &gt; 500 &amp;&amp; !customerid.StartsWith("--"))
                    {
                        try
                        {
                            File.WriteAllText(Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), "rzcat.json"), response);
                        }
                        catch { }
                    }

                    return lRes;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("E2" + ex.Message, "GetCatalog");
                Console.WriteLine("E2" + ex.Message, "GetCatalog");
                _sURL = ""; //enforce reload endpoint URL
            }

            return new List&lt;GetSoftware&gt;();
        }

        public static List&lt;string&gt; GetCategories(List&lt;GetSoftware&gt; oSWList)
        {
            List&lt;string&gt; lResult = new List&lt;string&gt;();

            foreach (GetSoftware oSW in oSWList)
            {
                lResult.AddRange((oSW.Categories ?? new List&lt;string&gt;()).ToArray());
            }

            return lResult.Distinct().OrderBy(t =&gt; t).ToList();
        }

        public static async Task&lt;byte[]&gt; GetIconAsync(string iconhash, string customerid = "", int size = 0, CancellationToken? ct = null)
        {
            if (ct == null)
                ct = new CancellationTokenSource(15000).Token;

            try
            {
                return await Task.Run(() =&gt;
                {
                    var response = oClient.GetStreamAsync(sURL + "/rest/v2/GetIcon?size=" + size + "&amp;iconhash=" + iconhash).Result; //add cts in .NET6

                    using (MemoryStream ms = new MemoryStream())
                    {
                        response.CopyTo(ms);
                        byte[] bRes = ms.ToArray();
                        return bRes;
                    }
                }, (CancellationToken)ct);
            }
            catch { }
            return null;
        }

        public static List&lt;AddSoftware&gt; GetSoftwares(string productName, string productVersion, string manufacturer, string customerid = "")
        {
            try
            {
                Task&lt;string&gt; response;

                if (string.IsNullOrEmpty(customerid))
                    response = oClient.GetStringAsync(sURL + "/rest/v2/GetSoftwares?name=" + WebUtility.UrlEncode(productName) + "&amp;ver=" + WebUtility.UrlEncode(productVersion) + "&amp;man=" + WebUtility.UrlEncode(manufacturer));
                else
                    response = oClient.GetStringAsync(sURL + "/rest/v2/GetSoftwares?name=" + WebUtility.UrlEncode(productName) + "&amp;ver=" + WebUtility.UrlEncode(productVersion) + "&amp;man=" + WebUtility.UrlEncode(manufacturer) + "&amp;customerid=" + WebUtility.UrlEncode(customerid));

                response.Wait(20000);
                if (response.IsCompleted)
                {
                    List&lt;AddSoftware&gt; lRes = GetObjectFromJson&lt;List&lt;AddSoftware&gt;&gt;(response.Result);

                    return lRes;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("E1" + ex.Message, "GetSoftwares");
                _sURL = ""; //enforce reload endpoint URL
            }

            return new List&lt;AddSoftware&gt;();
        }

        public static async Task&lt;List&lt;AddSoftware&gt;&gt; GetSoftwaresAsync(string productName, string productVersion, string manufacturer, string customerid = "", CancellationToken? ct = null)
        {
            if (ct == null)
                ct = new CancellationTokenSource(30000).Token; //30s Timeout

            //Task is just created to allow cancellation; Obsolete with .NET6
            return await Task.Run(async () =&gt;
            {
                try
                {
                    string response;

                    if (string.IsNullOrEmpty(customerid))
                        response = await oClient.GetStringAsync(sURL + "/rest/v2/GetSoftwares?name=" + WebUtility.UrlEncode(productName) + "&amp;ver=" + WebUtility.UrlEncode(productVersion) + "&amp;man=" + WebUtility.UrlEncode(manufacturer)); //add CT with .NET 6
                    else
                        response = await oClient.GetStringAsync(sURL + "/rest/v2/GetSoftwares?name=" + WebUtility.UrlEncode(productName) + "&amp;ver=" + WebUtility.UrlEncode(productVersion) + "&amp;man=" + WebUtility.UrlEncode(manufacturer) + "&amp;customerid=" + WebUtility.UrlEncode(customerid)); //add CT with .NET 6

                    List&lt;AddSoftware&gt; lRes = GetObjectFromJson&lt;List&lt;AddSoftware&gt;&gt;(response);

                    return lRes;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine("E1" + ex.Message, "GetSoftwares");
                    _sURL = ""; //enforce reload endpoint URL
                }

                return new List&lt;AddSoftware&gt;();
            });
        }

        public static async Task&lt;string&gt; GetURLAsync(string customerid, CancellationToken? ct = null)
        {
            if (ct == null)
                ct = new CancellationTokenSource(30000).Token; //30s Timeout

            //Task is just created to allow cancellation; Obsolete with .NET6
            return await Task.Run(() =&gt;
            {
                using (HttpClient hClient = new HttpClient())
                {
                    try
                    {
                        string tReq;

                        if (string.IsNullOrEmpty(CustomerID))
                        {
                            using (HttpClient qClient = new HttpClient())
                            {
                                CustomerID = hClient.GetStringAsync("https://ruckzuck.tools/rest/v2/getip").Result; //add cts with .net 6
                                customerid = CustomerID.ToString();
                            }
                        }

                        try
                        {
                            if (string.IsNullOrEmpty(customerid))
                            {
                                tReq = hClient.GetStringAsync("https://cdn.ruckzuck.tools/rest/v2/geturl").Result; //add cts with .net 6
                            }
                            else
                                tReq = hClient.GetStringAsync("https://cdn.ruckzuck.tools/rest/v2/geturl?customerid=" + customerid).Result; //add cts with .net 6

                            //Decode response parameters (for future use)
                            var nParams = HttpUtility.ParseQueryString(tReq);
                            if (nParams.Count == 0)
                            {
                                _sURL = tReq.Split('?')[0];
                            }
                            else
                            {
                                var cID = nParams.Get("customerid");
                                if (cID != null)
                                    CustomerID = cID.ToString();

                                _sURL = tReq.Split('?')[0];
                            }

                            return _sURL;
                        }
                        catch
                        {
                            _sURL = "https://ruckzuck.azurewebsites.net";
                            return _sURL;
                        }
                    }
                    catch { }

                    return "https://ruckzuck.azurewebsites.net";
                }
            }, (CancellationToken)ct);
        }

        public static async void IncCounter(string shortname = "", string counter = "DL", string customerid = "")
        {
            try
            {
                await oClient.GetStringAsync(sURL + "/rest/v2/IncCounter?shortname=" + WebUtility.UrlEncode(shortname) + "&amp;customerid=" + WebUtility.UrlEncode(CustomerID));
            }
            catch { }
        }

        public static bool UploadSWEntry(AddSoftware lSoftware, string customerid = "")
        {
            try
            {
                CancellationToken ct = new CancellationTokenSource(30000).Token; //30s Timeout

                HttpContent oCont = new StringContent(GetJsonFromObject(lSoftware), Encoding.UTF8, "application/json");

                var response = oClient.PostAsync(sURL + "/rest/v2/uploadswentry", oCont, ct);
                response.Wait(30000); //30s max

                if (response.Result.StatusCode == HttpStatusCode.OK)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            catch { }

            return false;
        }
    }
}</value>
  </data>
  <data name="RZUpdate" xml:space="preserve">
    <value>using RuckZuck.Base;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management.Automation;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Threading.Tasks;

namespace RZUpdate
{
    public static class AuthenticodeTools
    {
        //Source: https://stackoverflow.com/questions/6596327/how-to-check-if-a-file-is-signed-in-c

        [DllImport("Wintrust.dll", PreserveSig = true, SetLastError = false)]
        private static extern uint WinVerifyTrust(IntPtr hWnd, IntPtr pgActionID, IntPtr pWinTrustData);

        private static uint WinVerifyTrust(string fileName)
        {
            Guid wintrust_action_generic_verify_v2 = new Guid("{00AAC56B-CD44-11d0-8CC2-00C04FC295EE}");
            uint result = 0;
            using (WINTRUST_FILE_INFO fileInfo = new WINTRUST_FILE_INFO(fileName, Guid.Empty))
            using (WINTRUST_DATA.UnmanagedPointer guidPtr = new WINTRUST_DATA.UnmanagedPointer(Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Guid))), AllocMethod.HGlobal))
            using (WINTRUST_DATA.UnmanagedPointer wvtDataPtr = new WINTRUST_DATA.UnmanagedPointer(Marshal.AllocHGlobal(Marshal.SizeOf(typeof(WINTRUST_DATA))), AllocMethod.HGlobal))
            {
                WINTRUST_DATA data = new WINTRUST_DATA(fileInfo);
                IntPtr pGuid = guidPtr;
                IntPtr pData = wvtDataPtr;
                Marshal.StructureToPtr(wintrust_action_generic_verify_v2, pGuid, true);
                Marshal.StructureToPtr(data, pData, true);
                result = WinVerifyTrust(IntPtr.Zero, pGuid, pData);
            }
            return result;
        }

        public static bool IsTrusted(string fileName)
        {
            return WinVerifyTrust(fileName) == 0;
        }

        public struct WINTRUST_FILE_INFO : IDisposable
        {
            public WINTRUST_FILE_INFO(string fileName, Guid subject)
            {
                cbStruct = (uint)Marshal.SizeOf(typeof(WINTRUST_FILE_INFO));
                pcwszFilePath = fileName;

                if (subject != Guid.Empty)
                {
                    pgKnownSubject = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Guid)));
                    Marshal.StructureToPtr(subject, pgKnownSubject, true);
                }
                else
                {
                    pgKnownSubject = IntPtr.Zero;
                }

                hFile = IntPtr.Zero;
            }

            public uint cbStruct;

            [MarshalAs(UnmanagedType.LPTStr)]
            public string pcwszFilePath;

            public IntPtr hFile;
            public IntPtr pgKnownSubject;

            #region IDisposable Members

            public void Dispose()
            {
                Dispose(true);
            }

            private void Dispose(bool disposing)
            {
                if (pgKnownSubject != IntPtr.Zero)
                {
                    Marshal.DestroyStructure(this.pgKnownSubject, typeof(Guid));
                    Marshal.FreeHGlobal(this.pgKnownSubject);
                }
            }

            #endregion IDisposable Members
        }

        public enum AllocMethod
        {
            HGlobal,
            CoTaskMem
        };

        public enum UnionChoice
        {
            File = 1,
            Catalog,
            Blob,
            Signer,
            Cert
        };

        public enum UiChoice
        {
            All = 1,
            NoUI,
            NoBad,
            NoGood
        };

        public enum RevocationCheckFlags
        {
            None = 0,
            WholeChain
        };

        public enum StateAction
        {
            Ignore = 0,
            Verify,
            Close,
            AutoCache,
            AutoCacheFlush
        };

        public enum TrustProviderFlags
        {
            UseIE4Trust = 1,
            NoIE4Chain = 2,
            NoPolicyUsage = 4,
            RevocationCheckNone = 16,
            RevocationCheckEndCert = 32,
            RevocationCheckChain = 64,
            RecovationCheckChainExcludeRoot = 128,
            Safer = 256,
            HashOnly = 512,
            UseDefaultOSVerCheck = 1024,
            LifetimeSigning = 2048
        };

        public enum UIContext
        {
            Execute = 0,
            Install
        };

        [StructLayout(LayoutKind.Sequential)]
        public struct WINTRUST_DATA : IDisposable
        {
            public WINTRUST_DATA(WINTRUST_FILE_INFO fileInfo)
            {
                this.cbStruct = (uint)Marshal.SizeOf(typeof(WINTRUST_DATA));
                pInfoStruct = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(WINTRUST_FILE_INFO)));
                Marshal.StructureToPtr(fileInfo, pInfoStruct, false);
                this.dwUnionChoice = UnionChoice.File;

                pPolicyCallbackData = IntPtr.Zero;
                pSIPCallbackData = IntPtr.Zero;
                dwUIChoice = UiChoice.NoUI;
                fdwRevocationChecks = RevocationCheckFlags.None;
                dwStateAction = StateAction.Ignore;
                hWVTStateData = IntPtr.Zero;
                pwszURLReference = IntPtr.Zero;
                dwProvFlags = TrustProviderFlags.Safer;
                dwUIContext = UIContext.Execute;
            }

            public uint cbStruct;

            public IntPtr pPolicyCallbackData;

            public IntPtr pSIPCallbackData;

            public UiChoice dwUIChoice;

            public RevocationCheckFlags fdwRevocationChecks;

            public UnionChoice dwUnionChoice;

            public IntPtr pInfoStruct;

            public StateAction dwStateAction;

            public IntPtr hWVTStateData;

            private IntPtr pwszURLReference;

            public TrustProviderFlags dwProvFlags;

            public UIContext dwUIContext;

            #region IDisposable Members

            public void Dispose()
            {
                Dispose(true);
            }

            private void Dispose(bool disposing)
            {
                if (dwUnionChoice == UnionChoice.File)
                {
                    WINTRUST_FILE_INFO info = new WINTRUST_FILE_INFO();
                    Marshal.PtrToStructure(pInfoStruct, info);
                    info.Dispose();
                    Marshal.DestroyStructure(pInfoStruct, typeof(WINTRUST_FILE_INFO));
                }

                Marshal.FreeHGlobal(pInfoStruct);
            }

            #endregion IDisposable Members

            internal sealed class UnmanagedPointer : IDisposable
            {
                private IntPtr m_ptr;
                private AllocMethod m_meth;

                internal UnmanagedPointer(IntPtr ptr, AllocMethod method)
                {
                    m_meth = method;
                    m_ptr = ptr;
                }

                ~UnmanagedPointer()
                {
                    Dispose(false);
                }

                #region IDisposable Members

                private void Dispose(bool disposing)
                {
                    if (m_ptr != IntPtr.Zero)
                    {
                        if (m_meth == AllocMethod.HGlobal)
                        {
                            Marshal.FreeHGlobal(m_ptr);
                        }
                        else if (m_meth == AllocMethod.CoTaskMem)
                        {
                            Marshal.FreeCoTaskMem(m_ptr);
                        }

                        m_ptr = IntPtr.Zero;
                    }

                    if (disposing)
                    {
                        GC.SuppressFinalize(this);
                    }
                }

                public void Dispose()
                {
                    Dispose(true);
                }

                #endregion IDisposable Members

                public static implicit operator IntPtr(UnmanagedPointer ptr)
                {
                    return ptr.m_ptr;
                }
            }
        }
    }

    /// &lt;summary&gt;
    /// Updater Class
    /// &lt;/summary&gt;
    public class RZUpdater
    {
        /// &lt;summary&gt;
        /// Access to the SWUpdate
        /// &lt;/summary&gt;
        public SWUpdate SoftwareUpdate;

        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        public RZUpdater()
        {
            AddSoftware oSW = new AddSoftware();
            SoftwareUpdate = new SWUpdate(oSW);
            RZRestAPIv2.sURL.ToString(); //Required to initialize URL
        }

        public RZUpdater(string sSWFile)
        {
            if (sSWFile.EndsWith(".json", StringComparison.CurrentCultureIgnoreCase))
            {
                SoftwareUpdate = new SWUpdate(ParseJSON(sSWFile));
            }

            if (!File.Exists(sSWFile))
            {
                SoftwareUpdate = new SWUpdate(Parse(sSWFile));
            }
        }

        /// &lt;summary&gt;
        /// Check if there are Updates for a Software
        /// &lt;/summary&gt;
        /// &lt;param name="ProductName"&gt;Name of the Software Product (must be in the RuckZuck Repository !)&lt;/param&gt;
        /// &lt;param name="Version"&gt;&gt;Current Version of the Software&lt;/param&gt;
        /// &lt;returns&gt;SWUpdate if an Update is available otherwise null&lt;/returns&gt;
        public async Task&lt;SWUpdate&gt; CheckForUpdateAsync(string ProductName, string Version, string Manufacturer = "")
        {
            try
            {
                AddSoftware oSW = new AddSoftware();

                oSW.ProductName = ProductName;
                oSW.ProductVersion = Version;
                oSW.Manufacturer = Manufacturer ?? "";

                List&lt;AddSoftware&gt; oResult = (await RZRestAPIv2.CheckForUpdateAsync(new List&lt;AddSoftware&gt;() { oSW })).ToList();

                if (oResult.Count &gt; 0)
                {
                    foreach (AddSoftware SW in oResult)
                    {
                        if (SW.PSPreReq == null)
                        {
                            //Load all MetaData for the specific SW
                            foreach (AddSoftware SWCheck in await RZRestAPIv2.GetSoftwaresAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, RZRestAPIv2.CustomerID))
                            {
                                if (string.IsNullOrEmpty(SW.PSPreReq))
                                    SW.PSPreReq = "$true; ";

                                var pRes = await SWUpdate._RunPSAsync(SWCheck.PSPreReq);
                                if (pRes.Count &gt; 0)
                                {
                                    try
                                    {
                                        //Check PreReq for all Installation-types of the Software
                                        if ((bool)pRes[0].BaseObject)
                                        {
                                            SoftwareUpdate = new SWUpdate(SWCheck);
                                            return SoftwareUpdate;
                                        }
                                    }
                                    catch
                                    {
                                        continue;
                                    }
                                }
                                else
                                {
                                    continue;
                                }
                            }
                        }

                        if ((bool)(await SWUpdate._RunPSAsync(SW.PSPreReq)).Last().BaseObject)
                        {
                            SoftwareUpdate = new SWUpdate(SW);
                            return SoftwareUpdate;
                        }
                    }
                }

                return null;
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
                return null;
            }
        }

        internal static AddSoftware Parse(string sJSON)
        {
            try
            {
                AddSoftware lRes = RZRestAPIv2.GetObjectFromJson&lt;AddSoftware&gt;(sJSON);
                lRes.PreRequisites = lRes.PreRequisites.Where(x =&gt; !string.IsNullOrEmpty(x)).ToArray();
                return lRes;
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

            return new AddSoftware();
        }

        internal static AddSoftware ParseJSON(string sFile)
        {
            if (File.Exists(sFile))
            {
                try
                {
                    string sJson = File.ReadAllText(sFile);
                    AddSoftware lRes;

                    //Check if it's an Arrya (new in V2)
                    if (sJson.TrimStart().StartsWith("["))
                    {
                        List&lt;AddSoftware&gt; lItems = RZRestAPIv2.GetObjectFromJson&lt;List&lt;AddSoftware&gt;&gt;(sJson);
                        lRes = lItems[0];
                    }
                    else
                    {
                        lRes = RZRestAPIv2.GetObjectFromJson&lt;AddSoftware&gt;(sJson);
                    }

                    if (lRes.PreRequisites != null)
                    {
                        lRes.PreRequisites = lRes.PreRequisites.Where(x =&gt; !string.IsNullOrEmpty(x)).ToArray();
                    }
                    else
                        lRes.PreRequisites = new string[0];
                    return lRes;
                }
                catch { }
            }

            return new AddSoftware();
        }
    }

    /// &lt;summary&gt;
    /// SWUpdate Class
    /// &lt;/summary&gt;
    public class SWUpdate
    {
        public string ContentPath = "";
        public bool SendFeedback = true;
        public AddSoftware SW;
        internal DLTask downloadTask;

        private readonly ReaderWriterLockSlim UILock = new ReaderWriterLockSlim();

        //Constructor
        public SWUpdate(AddSoftware Software)
        {
            SW = Software;
            //downloadTask = new DLTask();
            downloadTask = new DLTask() { ProductName = SW.ProductName, ProductVersion = SW.ProductVersion, Manufacturer = SW.Manufacturer, ShortName = SW.ShortName, Files = SW.Files, UnInstalled = false, Installed = false, Installing = false, IconURL = SW.IconURL };
            downloadTask.SWUpd = this;

            if (SW.Files == null)
                SW.Files = new List&lt;contentFiles&gt;();
            if (SW.PreRequisites == null)
                SW.PreRequisites = new string[0];

            foreach (contentFiles vFile in SW.Files)
            {
                if (string.IsNullOrEmpty(vFile.HashType))
                    vFile.HashType = "MD5";
            }
        }

        //Constructor
        public SWUpdate(string ProductName, string ProductVersion, string Manufacturer, bool NoPreReqCheck = false)
        {
            SW = null;
            SW = new AddSoftware();

            SW.ProductName = ProductName;
            SW.ProductVersion = ProductVersion;
            SW.Manufacturer = Manufacturer;

            downloadTask = new DLTask() { ProductName = SW.ProductName, ProductVersion = SW.ProductVersion, Manufacturer = SW.Manufacturer, UnInstalled = false, Installed = false };
            downloadTask.SWUpd = this;

            //Get Install-type
            if (!GetInstallType(NoPreReqCheck))
            {
                SW = null;
                return;
            }

            downloadTask = new DLTask() { ProductName = SW.ProductName, ProductVersion = SW.ProductVersion, Manufacturer = SW.Manufacturer, ShortName = SW.ShortName, IconURL = SW.IconURL, Files = SW.Files, UnInstalled = false, Installed = false };

            if (SW == null)
            {
                //Load all MetaData for the specific SW
                foreach (AddSoftware SWCheck in RZRestAPIv2.GetSoftwaresAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, RZRestAPIv2.CustomerID).Result)
                {
                    if (string.IsNullOrEmpty(SWCheck.PSPreReq))
                        SWCheck.PSPreReq = "$true; ";

                    //Check PreReq for all Installation-types of the Software
                    if ((bool)(SWUpdate._RunPSAsync(SWCheck.PSPreReq).GetAwaiter().GetResult())[0].BaseObject)
                    {
                        SW = SWCheck;
                        break;
                    }
                }

                //SW = RZRestAPIv2.GetSoftwares(ProductName, ProductVersion, Manufacturer, RZRestAPIv2.CustomerID).FirstOrDefault();

                if (SW.Files == null)
                    SW.Files = new List&lt;contentFiles&gt;();

                if (string.IsNullOrEmpty(SW.PSPreReq))
                    SW.PSPreReq = "$true; ";
            }

            if (SW.Files != null)
            {
                foreach (contentFiles vFile in SW.Files)
                {
                    if (string.IsNullOrEmpty(vFile.HashType))
                        vFile.HashType = "MD5";
                }
            }

            if (SW.PreRequisites == null)
                SW.PreRequisites = new string[0];
        }

        public SWUpdate(string ShortName)
        {
            SW = null;
            downloadTask = new DLTask();
            downloadTask.SWUpd = this;
            downloadTask.ShortName = ShortName;

            try
            {
                SW = new AddSoftware();

                string sBaseDir = AppDomain.CurrentDomain.BaseDirectory;

                //Always use local JSON-File if exists
                if (File.Exists(Path.Combine(sBaseDir, ShortName + ".json")))
                {
                    string sSWFile = Path.Combine(sBaseDir, ShortName + ".json");
                    SW = new SWUpdate(RZUpdater.ParseJSON(sSWFile)).SW;
                }
                else
                {
                    //Always use local JSON-File if exists
                    if (File.Exists(Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), ShortName + ".json")))
                    {
                        string sSWFile = Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), ShortName + ".json");
                        SW = new SWUpdate(RZUpdater.ParseJSON(sSWFile)).SW;
                    }
                    else
                    {
                        var oGetSW = RZRestAPIv2.GetCatalogAsync(RZRestAPIv2.CustomerID).Result.Where(t =&gt; t.ShortName.ToLower() == ShortName.ToLower()).FirstOrDefault(); // RZRestAPI.SWGet(ShortName).FirstOrDefault();
                        if (oGetSW != null)
                        {
                            SW.ProductName = oGetSW.ProductName;
                            SW.ProductVersion = oGetSW.ProductVersion;
                            SW.Manufacturer = oGetSW.Manufacturer;
                            SW.ShortName = ShortName;

                            if (SW.Architecture == null)
                            {
                                //Load all MetaData for the specific SW
                                foreach (AddSoftware SWCheck in RZRestAPIv2.GetSoftwaresAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, RZRestAPIv2.CustomerID).Result)
                                {
                                    if (string.IsNullOrEmpty(SWCheck.PSPreReq))
                                        SWCheck.PSPreReq = "$true; ";

                                    //Check PreReq for all Installation-types of the Software
                                    if ((bool)SWUpdate._RunPSAsync(SWCheck.PSPreReq).Result[0].BaseObject)
                                    {
                                        SW = SWCheck;
                                        break;
                                    }
                                }

                                //SW = RZRestAPIv2.GetSoftwares(oGetSW.ProductName, oGetSW.ProductVersion, oGetSW.Manufacturer, RZRestAPIv2.CustomerID).FirstOrDefault();
                                if (SW == null) { Console.WriteLine("No SW"); }
                                SW.ShortName = ShortName;

                                if (SW.Files == null)
                                    SW.Files = new List&lt;contentFiles&gt;();
                                if (string.IsNullOrEmpty(SW.PSPreReq))
                                    SW.PSPreReq = "$true; ";
                            }
                        }

                        if (string.IsNullOrEmpty(SW.PSInstall))
                            return;

                        //Get Install-type
                        GetInstallType();
                    }
                }

                downloadTask = new DLTask() { ProductName = SW.ProductName, ProductVersion = SW.ProductVersion, Manufacturer = SW.Manufacturer, ShortName = SW.ShortName, IconURL = SW.IconURL, Files = SW.Files };
                foreach (contentFiles vFile in SW.Files)
                {
                    if (string.IsNullOrEmpty(vFile.HashType))
                        vFile.HashType = "MD5";
                }
                if (SW.PreRequisites == null)
                    SW.PreRequisites = new string[0];
            }
            catch { }
        }

        public delegate void ChangedEventHandler(object sender, EventArgs e);

        public event ChangedEventHandler Downloaded;

        public event EventHandler ProgressDetails = delegate { };

        private static event EventHandler DLProgress = delegate { };

        /// &lt;summary&gt;
        /// Run PowerShell
        /// &lt;/summary&gt;
        /// &lt;param name="PSScript"&gt;PowerShell Script&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static PSDataCollection&lt;PSObject&gt; _RunPS(string PSScript, string WorkingDir = "", TimeSpan? Timeout = null)
        {
            TimeSpan timeout = new TimeSpan(0, 15, 0); //default timeout = 15min

            if (Timeout != null)
                timeout = (TimeSpan)Timeout;

            DateTime dStart = DateTime.Now;
            TimeSpan dDuration = DateTime.Now - dStart;
            using (PowerShell PowerShellInstance = PowerShell.Create())
            {
                if (!string.IsNullOrEmpty(WorkingDir))
                {
                    WorkingDir = Path.GetDirectoryName(WorkingDir);
                    PSScript = "Set-Location -Path '" + WorkingDir + "';" + PSScript;
                }

                PowerShellInstance.AddScript(PSScript);
                PSDataCollection&lt;PSObject&gt; outputCollection = new PSDataCollection&lt;PSObject&gt;();

                outputCollection.DataAdding += ConsoleOutput;
                PowerShellInstance.Streams.Error.DataAdding += ConsoleError;

                IAsyncResult async = PowerShellInstance.BeginInvoke&lt;PSObject, PSObject&gt;(null, outputCollection);
                while (async.IsCompleted == false &amp;&amp; dDuration &lt;= timeout)
                {
                    Thread.Sleep(200);
                    dDuration = DateTime.Now - dStart;
                }

                return outputCollection;
            }
        }

        public static async Task&lt;PSDataCollection&lt;PSObject&gt;&gt; _RunPSAsync(string PSScript, string WorkingDir = "", TimeSpan? Timeout = null)
        {
            TimeSpan timeout = new TimeSpan(0, 15, 0); //default timeout = 15min

            if (Timeout != null)
                timeout = (TimeSpan)Timeout;

            DateTime dStart = DateTime.Now;
            TimeSpan dDuration = DateTime.Now - dStart;
            using (PowerShell PowerShellInstance = PowerShell.Create())
            {
                if (!string.IsNullOrEmpty(WorkingDir))
                {
                    WorkingDir = Path.GetDirectoryName(WorkingDir);
                    PSScript = "Set-Location -Path '" + WorkingDir + "';" + PSScript;
                }

                PowerShellInstance.AddScript(PSScript);
                PSDataCollection&lt;PSObject&gt; outputCollection = new PSDataCollection&lt;PSObject&gt;();

                outputCollection.DataAdding += ConsoleOutput;
                PowerShellInstance.Streams.Error.DataAdding += ConsoleError;

                await Task.Factory.FromAsync(PowerShellInstance.BeginInvoke&lt;PSObject, PSObject&gt;(null, outputCollection), pResult =&gt; PowerShellInstance.EndInvoke(pResult));

                return outputCollection;
            }
        }

        /// &lt;summary&gt;
        /// Download a File
        /// &lt;/summary&gt;
        /// &lt;param name="URL"&gt;&lt;/param&gt;
        /// &lt;param name="FileName"&gt;&lt;/param&gt;
        /// &lt;returns&gt;true = success; false = error&lt;/returns&gt;
        public async Task&lt;bool&gt; _DownloadFile2Async(string URL, string FileName, long FileSize = 0)
        {
            //Check if URL is HTTP, otherwise it must be a PowerShell
            if (!URL.StartsWith("http", StringComparison.CurrentCultureIgnoreCase) &amp;&amp; !URL.StartsWith("ftp", StringComparison.CurrentCultureIgnoreCase))
            {
                var oResults = await _RunPSAsync(URL, FileName, new TimeSpan(2, 0, 0)); //2h timeout
                if (File.Exists(FileName))
                {
                    DLProgress((int)100, EventArgs.Empty);
                    ProgressDetails(new DLStatus() { Filename = FileName, URL = URL, PercentDownloaded = 100, DownloadedBytes = 100, TotalBytes = 100 }, EventArgs.Empty);
                    return true;
                }

                URL = oResults.FirstOrDefault().BaseObject.ToString();
            }

            try
            {
                Stream ResponseStream = null;
                WebResponse Response = null;

                Int64 ContentLength = 1;
                Int64 ContentLoaded = 0;
                Int64 ioldProgress = 0;
                Int64 iProgress = 0;

                if (URL.StartsWith("http", StringComparison.CurrentCultureIgnoreCase))
                {
                    //_DownloadFile(URL, FileName).Result.ToString();
                    var httpRequest = (HttpWebRequest)WebRequest.Create(URL);
                    httpRequest.UserAgent = "chocolatey command line";
                    httpRequest.AllowAutoRedirect = true;
                    httpRequest.MaximumAutomaticRedirections = 5;
                    Response = httpRequest.GetResponse();

                    // Get back the HTTP response for web server
                    //Response = (HttpWebResponse)httpRequest.GetResponse();
                    ResponseStream = Response.GetResponseStream();
                }

                if (URL.StartsWith("ftp", StringComparison.CurrentCultureIgnoreCase))
                {
                    var ftpRequest = (FtpWebRequest)WebRequest.Create(URL);
                    ftpRequest.ContentLength.ToString();
                    ftpRequest.GetResponse();

                    // Get back the HTTP response for web server
                    Response = (FtpWebResponse)ftpRequest.GetResponse();
                    ResponseStream = Response.GetResponseStream();

                    ContentLength = Response.ContentLength;
                }

                if (URL.StartsWith("&lt;skip&gt;", StringComparison.CurrentCultureIgnoreCase))
                {
                    DLProgress(100, EventArgs.Empty);
                    return true;
                }

                if (ResponseStream == null)
                    return false;

                // Define buffer and buffer size
                int bufferSize = 32768; //4096;
                byte[] buffer = new byte[bufferSize];
                int bytesRead = 0;

                // Read from response and write to file
                FileStream fileStream = File.Create(FileName);
                while ((bytesRead = await ResponseStream.ReadAsync(buffer, 0, bufferSize)) != 0)
                {
                    if (FileSize &gt; 0)
                    {
                        ContentLength = FileSize;
                    }
                    else
                    {
                        if (ContentLength == 1) { Int64.TryParse(Response.Headers.Get("Content-Length"), out ContentLength); }
                    }

                    await fileStream.WriteAsync(buffer, 0, bytesRead);
                    ContentLoaded = ContentLoaded + bytesRead;

                    try
                    {
                        iProgress = (100 * ContentLoaded) / ContentLength;
                        //only send status on percent change
                        if (iProgress != ioldProgress)
                        {
                            if ((iProgress % 10) == 5 || (iProgress % 10) == 0)
                            {
                                try
                                {
                                    DLProgress((int)iProgress, EventArgs.Empty);
                                    ProgressDetails(new DLStatus() { Filename = FileName, URL = URL, PercentDownloaded = Convert.ToInt32(iProgress), DownloadedBytes = ContentLoaded, TotalBytes = ContentLength }, EventArgs.Empty);
                                    ioldProgress = iProgress;
                                }
                                catch { }
                            }
                        }
                    }
                    catch { }
                } // end while

                try
                {
                    if (ioldProgress != 100)
                    {
                        iProgress = (100 * ContentLoaded) / ContentLength;
                        DLProgress((int)iProgress, EventArgs.Empty);
                        ProgressDetails(new DLStatus() { Filename = FileName, URL = URL, PercentDownloaded = Convert.ToInt32(iProgress), DownloadedBytes = ContentLoaded, TotalBytes = ContentLength }, EventArgs.Empty);
                        ioldProgress = iProgress;
                    }
                }
                catch { }

                fileStream.Close();
                ResponseStream.Close();
                //Response.Close();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex.Message);
                Console.WriteLine(ex.Message);
                return false;
            }

            return true;
        }

        /// &lt;summary&gt;
        /// Check if PreReq from Install-Type are compliant (true).
        /// &lt;/summary&gt;
        /// &lt;returns&gt;true = compliant; false = noncompliant&lt;/returns&gt;
        public async Task&lt;bool&gt; CheckDTPreReqAsync()
        {
            if (SW != null)
            {
                //Is Product already installed ?
                try
                {
                    if (string.IsNullOrEmpty(SW.PSPreReq))
                        SW.PSPreReq = "$true; ";
                    //Already installed ?
                    if ((bool)(await _RunPSAsync(SW.PSPreReq)).Last().BaseObject)
                    {
                        return true;
                    }
                }
                catch { }
            }

            return false;
        }

        /// &lt;summary&gt;
        /// Check if Install-Type is installed
        /// &lt;/summary&gt;
        /// &lt;returns&gt;true = installed ; false = not installed&lt;/returns&gt;
        public bool CheckIsInstalled(bool sendProgressEvent)
        {
            if (SW != null)
            {
                //Is Product already installed ?
                try
                {
                    //Already installed ?
                    if ((bool)_RunPS(SW.PSDetection).Last().BaseObject)
                    {
                        UILock.EnterReadLock();
                        try
                        {
                            downloadTask.Installed = true;
                            downloadTask.Installing = false;
                            downloadTask.Downloading = false;
                            downloadTask.WaitingForDependency = false;
                            downloadTask.Error = false;
                            downloadTask.ErrorMessage = "";
                            downloadTask.PercentDownloaded = 100;

                            if (sendProgressEvent)
                                ProgressDetails(downloadTask, EventArgs.Empty);
                        }
                        finally { UILock.ExitReadLock(); }
                        return true;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }

                downloadTask.Installed = false;
                downloadTask.Installing = false;
                downloadTask.Downloading = false;
            }
            else
            {
                downloadTask.Installed = false;
                downloadTask.Installing = false;
                downloadTask.Downloading = false;
                downloadTask.PercentDownloaded = 0;
            }

            if (sendProgressEvent)
                ProgressDetails(downloadTask, EventArgs.Empty);
            return false;
        }

        /// &lt;summary&gt;
        /// Download all related Files to %TEMP%
        /// &lt;/summary&gt;
        /// &lt;returns&gt;true = success&lt;/returns&gt;
        public async Task&lt;bool&gt; DownloadAsync()
        {
            bool bAutoInstall = downloadTask.AutoInstall;
            downloadTask = new DLTask() { ProductName = SW.ProductName, ProductVersion = SW.ProductVersion, Manufacturer = SW.Manufacturer, ShortName = SW.ShortName, IconURL = SW.IconURL, Files = SW.Files };
            if (SW.PreRequisites != null)
            {
                if (SW.PreRequisites.Length &gt; 0)
                {
                    downloadTask.WaitingForDependency = true;
                    downloadTask.AutoInstall = false;
                }
                else
                {
                    downloadTask.AutoInstall = bAutoInstall;
                }
            }
            else
            {
                downloadTask.AutoInstall = bAutoInstall;
            }
            downloadTask.Error = false;
            downloadTask.SWUpd = this;
            downloadTask.Downloading = true;
            ProgressDetails += SWUpdate_ProgressDetails;
            bool bResult = await _DownloadAsync(false, Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), SW.ContentID));
            return bResult;
        }

        /// &lt;summary&gt;
        /// Download all related Files to %TEMP%
        /// &lt;/summary&gt;
        /// &lt;param name="Enforce"&gt;True = do not check if SW is already installed&lt;/param&gt;
        /// &lt;returns&gt;true = success&lt;/returns&gt;
        public async Task&lt;bool&gt; DownloadAsync(bool Enforce)
        {
            return await DownloadAsync(Enforce, Path.Combine(Environment.ExpandEnvironmentVariables("%TEMP%"), SW.ContentID));
        }

        public async Task&lt;bool&gt; DownloadAsync(bool Enforce, string DLPath)
        {
            bool bAutoInstall = downloadTask.AutoInstall;
            downloadTask = new DLTask() { ProductName = SW.ProductName, ProductVersion = SW.ProductVersion, Manufacturer = SW.Manufacturer, ShortName = SW.ShortName, IconURL = SW.IconURL, Files = SW.Files };

            if (SW.PreRequisites != null)
            {
                if (SW.PreRequisites.Length &gt; 0)
                {
                    downloadTask.WaitingForDependency = true;
                    downloadTask.AutoInstall = false;
                }
                else
                {
                    downloadTask.AutoInstall = bAutoInstall;
                }
            }
            else
            {
                downloadTask.AutoInstall = bAutoInstall;
            }
            downloadTask.Error = false;
            downloadTask.SWUpd = this;
            downloadTask.Downloading = true;
            ProgressDetails += SWUpdate_ProgressDetails;

            bool bResult = await _DownloadAsync(Enforce, DLPath);
            return bResult;
        }

        public string GetDLPath()
        {
            return Environment.ExpandEnvironmentVariables("%TEMP%\\" + SW.ContentID.ToString());
        }

        public bool GetInstallType(bool bGetFirst = false)
        {
            //Only get other DeploymentTypes if Architecture is not defined...
            if (string.IsNullOrEmpty(this.SW.Architecture))
            {
                foreach (var DT in RZRestAPIv2.GetSoftwares(SW.ProductName, SW.ProductVersion, SW.Manufacturer, RZRestAPIv2.CustomerID))
                {
                    try
                    {
                        //Check PreReqs
                        try
                        {
                            if (!string.IsNullOrEmpty(DT.PSPreReq))
                            {
                                if (!bGetFirst)
                                {
                                    if (!(bool)_RunPS(DT.PSPreReq).Last().BaseObject)
                                        continue;
                                }
                            }
                        }
                        catch { continue; }

                        SW = DT;

                        return true;
                    }
                    catch { }
                }

                return false;
            }

            return true;
        }

        public async Task&lt;bool&gt; InstallAsync(bool Force = false, bool Retry = false)
        {
            bool msiIsRunning = false;
            bool RZisRunning = false;
            do
            {
                //Check if MSI is running...
                try
                {
                    using (var mutex = Mutex.OpenExisting(@"Global\_MSIExecute"))
                    {
                        msiIsRunning = true;
                        if (Retry)
                        {
                            Console.WriteLine("Warning: Windows-Installer setup is already running!... waiting...");
                            Thread.Sleep(new TimeSpan(0, 0, 10));
                        }
                        else
                            return false;
                    }
                    GC.Collect();
                }
                catch
                {
                    msiIsRunning = false;
                }

                //Check if RuckZuckis running...
                try
                {
                    using (var mutex = Mutex.OpenExisting(@"Global\RuckZuck"))
                    {
                        RZisRunning = true;
                        if (Retry)
                        {
                            Console.WriteLine("Warning: RuckZuck setup is already running!... waiting...");
                            Thread.Sleep(new TimeSpan(0, 0, 10));
                        }
                        else
                            return false;
                    }
                    GC.Collect();
                }
                catch
                {
                    RZisRunning = false;
                }
            }
            while (msiIsRunning || RZisRunning);

            bool bMutexCreated = false;
            bool bResult = false;

            using (Mutex mutex = new Mutex(false, "Global\\RuckZuck", out bMutexCreated))
            {
                bResult = await _InstallAsync(Force);

                if (bMutexCreated)
                    mutex.Close();
            }
            GC.Collect();
            return bResult;
        }

        public async Task&lt;bool&gt; UnInstall(bool Force = false, bool Retry = false)
        {
            bool msiIsRunning = false;
            bool RZisRunning = false;
            do
            {
                //Check if MSI is running...
                try
                {
                    using (var mutex = Mutex.OpenExisting(@"Global\_MSIExecute"))
                    {
                        msiIsRunning = true;
                        if (Retry)
                        {
                            Console.WriteLine("Warning: Windows-Installer setup is already running!... waiting...");
                            Thread.Sleep(new TimeSpan(0, 0, 10));
                        }
                        else
                            return false;
                    }
                    GC.Collect();
                }
                catch
                {
                    msiIsRunning = false;
                }

                //Check if RuckZuckis running...
                try
                {
                    using (var mutex = Mutex.OpenExisting(@"Global\RuckZuck"))
                    {
                        RZisRunning = true;
                        if (Retry)
                        {
                            Console.WriteLine("Warning: RuckZuck setup is already running!... waiting...");
                            Thread.Sleep(new TimeSpan(0, 0, 10));
                        }
                        else
                            return false;
                    }
                    GC.Collect();
                }
                catch
                {
                    RZisRunning = false;
                }
            }
            while (msiIsRunning || RZisRunning);

            bool bMutexCreated = false;
            bool bResult = false;

            using (Mutex mutex = new Mutex(false, "Global\\RuckZuck", out bMutexCreated))
            {
                bResult = await _UnInstallAsync(Force);

                if (bMutexCreated)
                    mutex.Close();
            }
            GC.Collect();
            return bResult;
        }

        private static void ConsoleError(object sender, DataAddingEventArgs e)
        {
            if (e.ItemAdded != null)
                Console.WriteLine("ERROR:" + e.ItemAdded.ToString());
        }

        private static void ConsoleOutput(object sender, DataAddingEventArgs e)
        {
            //if (e.ItemAdded != null)
            //    Console.WriteLine(e.ItemAdded.ToString());
        }

        private bool _checkFileMd5(string FilePath, string MD5)
        {
            try
            {
                using (var md5 = System.Security.Cryptography.MD5.Create())
                {
                    using (var stream = File.OpenRead(FilePath))
                    {
                        if (MD5.ToLower() != BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", "").ToLower())
                            return false;
                        else
                            return true;
                    }
                }
            }
            catch
            {
                return false;
            }
        }

        //    return true;
        //}
        private bool _checkFileSHA1(string FilePath, string SHA1)
        {
            try
            {
                using (var sha1 = System.Security.Cryptography.SHA1.Create())
                {
                    using (var stream = File.OpenRead(FilePath))
                    {
                        if (SHA1.ToLower() != BitConverter.ToString(sha1.ComputeHash(stream)).Replace("-", "").ToLower())
                            return false;
                        else
                            return true;
                    }
                }
            }
            catch
            {
                return false;
            }
        }

        //    }
        //    catch (Exception ex)
        //    {
        //        Console.WriteLine(ex.Message);
        //        return false;
        //    }
        private bool _checkFileSHA256(string FilePath, string SHA256)
        {
            try
            {
                using (var sha256 = System.Security.Cryptography.SHA256.Create())
                {
                    using (var stream = File.OpenRead(FilePath))
                    {
                        if (SHA256.ToLower() != BitConverter.ToString(sha256.ComputeHash(stream)).Replace("-", "").ToLower())
                            return false;
                        else
                            return true;
                    }
                }
            }
            catch
            {
                return false;
            }
        }

        //                using (Stream streamToWriteTo = File.Open(fileToWriteTo, FileMode.Create))
        //                {
        //                    await streamToReadFrom.CopyToAsync(streamToWriteTo);
        //                }
        //                Console.WriteLine("Donwloaded: " + URL);
        //            }
        //        }
        private async Task&lt;bool&gt; _checkFileX509Async(string FilePath, string X509)
        {
            return await Task.Run(() =&gt;
            {
                try
                {
                    var Cert = X509Certificate.CreateFromSignedFile(FilePath);
                    if (Cert.GetCertHashString().ToLower().Replace(" ", "") == X509.ToLower())
                    {
                        return AuthenticodeTools.IsTrusted(FilePath);
                    }
                    else
                        return false;
                }
                catch
                {
                    return false;
                }
            });

        }

        private async Task&lt;bool&gt; _DownloadAsync(bool Enforce, string DLPath)
        {
            bool bError = false;
            ContentPath = DLPath;
            if (!Enforce)
            {
                //Check if it's still required
                try
                {
                    if (CheckIsInstalled(true))
                    {
                        if (Downloaded != null)
                            Downloaded(downloadTask, EventArgs.Empty);
                        return true;
                    }
                }
                catch { }
            }
            if (SW.Files == null)
                SW.Files = new List&lt;contentFiles&gt;();

            //only XML File contains Files
            if (SW.Files.Count() &gt; 0)
            {
                bool bDLSuccess = false;
                foreach (var vFile in SW.Files)
                {
                    try
                    {
                        if (string.IsNullOrEmpty(vFile.URL))
                        {
                            downloadTask.PercentDownloaded = 100;
                            ProgressDetails(downloadTask, EventArgs.Empty);
                            continue;
                        }

                        string sDir = DLPath; // Path.Combine(Environment.ExpandEnvironmentVariables(DLPath), SW.ContentID);

                        string sFile = Path.Combine(sDir, vFile.FileName);

                        if (!Directory.Exists(sDir))
                            Directory.CreateDirectory(sDir);

                        bool bDownload = true;

                        //Check File-Hash on existing Files...
                        if (File.Exists(sFile))
                        {
                            if (string.IsNullOrEmpty(vFile.FileHash))
                            {
                                File.Delete(sFile);
                            }
                            else
                            {
                                if (string.IsNullOrEmpty(vFile.HashType))
                                    vFile.HashType = "MD5";

                                if (vFile.HashType.ToUpper() == "MD5")
                                {
                                    if (!_checkFileMd5(sFile, vFile.FileHash))
                                    {
                                        Console.WriteLine("Hash mismatch on existing File " + vFile.FileName);
                                        File.Delete(sFile); //Hash mismatch
                                    }
                                    else
                                        bDownload = false; //Do not download, Hash is valid
                                }
                                if (vFile.HashType.ToUpper() == "SHA1")
                                {
                                    if (!_checkFileSHA1(sFile, vFile.FileHash))
                                        File.Delete(sFile); //Hash mismatch
                                    else
                                        bDownload = false; //Do not download, Hash is valid
                                }
                                if (vFile.HashType.ToUpper() == "SHA256")
                                {
                                    if (!_checkFileSHA256(sFile, vFile.FileHash))
                                        File.Delete(sFile); //Hash mismatch
                                    else
                                        bDownload = false; //Do not download, Hash is valid
                                }

                                if (vFile.HashType.ToUpper() == "X509")
                                {
                                    if (!await _checkFileX509Async(sFile, vFile.FileHash))
                                        File.Delete(sFile); //Hash mismatch
                                    else
                                        bDownload = false; //Do not download, Hash is valid
                                }
                            }
                        }

                        if (bDownload)
                        {
                            downloadTask.PercentDownloaded = 0;
                            downloadTask.Downloading = true;
                            ProgressDetails(downloadTask, EventArgs.Empty);

                            if (!await _DownloadFile2Async(vFile.URL, sFile, vFile.FileSize))
                            {
                                downloadTask.Error = true;
                                downloadTask.PercentDownloaded = 0;
                                downloadTask.ErrorMessage = "ERROR: download failed... " + vFile.FileName;
                                Console.WriteLine("ERROR: download failed... " + vFile.FileName);
                                ProgressDetails(downloadTask, EventArgs.Empty);
                                File.Delete(sFile);
                                if (SendFeedback)
                                    await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "download failed", RZRestAPIv2.CustomerID).ConfigureAwait(false);
                                return false;
                            }
                            else
                            {
                                bDLSuccess = true;
                            }

                            ProgressDetails(downloadTask, EventArgs.Empty);
                            //downloadTask.Downloading = false;
                        }
                        else
                        {
                            downloadTask.PercentDownloaded = 100;
                            downloadTask.Downloading = false;
                        }

                        //Only Check Hash if downloaded
                        if (!string.IsNullOrEmpty(vFile.FileHash) &amp;&amp; bDownload)
                        {
                            if (!vFile.URL.StartsWith("http", StringComparison.InvariantCultureIgnoreCase) &amp;&amp; !File.Exists(sFile))
                            {
                                downloadTask.PercentDownloaded = 100;
                                downloadTask.Error = false;
                            }
                            else
                            {
                                if (string.IsNullOrEmpty(vFile.HashType))
                                    vFile.HashType = "MD5";

                                //Check if there is a File
                                long iFileSize = 0;
                                try
                                {
                                    FileInfo fi = new FileInfo(sFile);
                                    iFileSize = fi.Length;
                                }
                                catch { }

                                if (iFileSize == 0)
                                {
                                    downloadTask.Error = true;
                                    downloadTask.PercentDownloaded = 0;
                                    downloadTask.ErrorMessage = "ERROR: empty File... " + vFile.FileName;
                                    Console.WriteLine("ERROR: empty File... " + vFile.FileName);
                                    ProgressDetails(downloadTask, EventArgs.Empty);
                                    File.Delete(sFile);
                                    return false;
                                }
                                else
                                {
                                    //Check default MD5 Hash
                                    if (vFile.HashType.ToUpper() == "MD5")
                                    {
                                        if (!_checkFileMd5(sFile, vFile.FileHash))
                                        {
                                            downloadTask.Error = true;
                                            downloadTask.PercentDownloaded = 0;
                                            downloadTask.ErrorMessage = "ERROR: Hash mismatch on File " + vFile.FileName;
                                            Console.WriteLine("ERROR: Hash mismatch on File " + vFile.FileName);
                                            File.Delete(sFile);
                                            if (SendFeedback)
                                                await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Hash mismatch").ConfigureAwait(false);
                                            bError = true;
                                        }
                                        else
                                        {
                                            downloadTask.PercentDownloaded = 100;
                                        }
                                    }

                                    //Check default SHA1 Hash
                                    if (vFile.HashType.ToUpper() == "SHA1")
                                    {
                                        if (!_checkFileSHA1(sFile, vFile.FileHash))
                                        {
                                            downloadTask.Error = true;
                                            downloadTask.PercentDownloaded = 0;
                                            downloadTask.ErrorMessage = "ERROR: Hash mismatch on File " + vFile.FileName;
                                            Console.WriteLine("ERROR: Hash mismatch on File " + vFile.FileName);
                                            File.Delete(sFile);
                                            if (SendFeedback)
                                                await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Hash mismatch", RZRestAPIv2.CustomerID).ConfigureAwait(false);
                                            bError = true;
                                        }
                                        else
                                        {
                                            downloadTask.PercentDownloaded = 100;
                                        }
                                    }

                                    //Check default SHA256 Hash
                                    if (vFile.HashType.ToUpper() == "SHA256")
                                    {
                                        if (!_checkFileSHA256(sFile, vFile.FileHash))
                                        {
                                            downloadTask.Error = true;
                                            downloadTask.PercentDownloaded = 0;
                                            downloadTask.ErrorMessage = "ERROR: Hash mismatch on File " + vFile.FileName;
                                            Console.WriteLine("ERROR: Hash mismatch on File " + vFile.FileName);
                                            File.Delete(sFile);
                                            if (SendFeedback)
                                                await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Hash mismatch", RZRestAPIv2.CustomerID).ConfigureAwait(false);
                                            bError = true;
                                        }
                                        else
                                        {
                                            downloadTask.PercentDownloaded = 100;
                                        }
                                    }

                                    if (vFile.HashType.ToUpper() == "X509")
                                    {
                                        if (!await _checkFileX509Async(sFile, vFile.FileHash))
                                        {
                                            downloadTask.Error = true;
                                            downloadTask.PercentDownloaded = 0;
                                            downloadTask.ErrorMessage = "ERROR: Signature mismatch on File " + vFile.FileName;
                                            Console.WriteLine("ERROR: Signature mismatch on File " + vFile.FileName);
                                            File.Delete(sFile);
                                            if (SendFeedback)
                                                await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Signature mismatch", RZRestAPIv2.CustomerID).ConfigureAwait(false);
                                            bError = true;
                                        }
                                        else
                                        {
                                            downloadTask.PercentDownloaded = 100;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        downloadTask.PercentDownloaded = 0;
                        downloadTask.ErrorMessage = ex.Message;
                        Console.WriteLine("ERROR: " + ex.Message);
                        bError = true;
                    }
                }

                if (SendFeedback &amp;&amp; bDLSuccess)
                {
                    RZRestAPIv2.IncCounter(SW.ShortName, customerid: RZRestAPIv2.CustomerID);
                }
            }
            else
            {
                downloadTask.PercentDownloaded = 100;
            }

            downloadTask.Downloading = false;

            if (bError)
            {
                downloadTask.PercentDownloaded = 0;
                downloadTask.Error = true;
            }
            else
            {
                downloadTask.Error = false;
                downloadTask.ErrorMessage = "";
            }

            ProgressDetails(downloadTask, EventArgs.Empty);

            if (Downloaded != null)
                Downloaded(downloadTask, EventArgs.Empty);

            return !bError;
        }

        /// &lt;summary&gt;
        /// Install a SWUpdate
        /// &lt;/summary&gt;
        /// &lt;param name="Force"&gt;Do not check if SW is already installed.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private async Task&lt;bool&gt; _InstallAsync(bool Force = false)
        {
            bool bError = false;

            //Check if Installer is already running
            if (downloadTask.Installing)
            {
                Thread.Sleep(1500);
                return CheckIsInstalled(true); ;
            }

            downloadTask.Installing = true;
            if (!await CheckDTPreReqAsync())
            {
                Console.WriteLine("Requirements not valid. Installation will not start.");
                downloadTask.Installing = false;
                downloadTask.Installed = false;
                downloadTask.Error = true;
                downloadTask.ErrorMessage = "Requirements not valid. Installation will not start.";
                ProgressDetails(this.downloadTask, EventArgs.Empty);

                if (SendFeedback)
                    await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Requirements not valid. Installation will not start.", RZRestAPIv2.CustomerID).ConfigureAwait(false);

                return false;
            }

            //Is Product already installed ?
            try
            {
                if (!Force)
                {
                    //Already installed ?
                    if (CheckIsInstalled(true))
                    {
                        return true;
                    }
                }

                downloadTask.Installing = true;

                //Set CurrentDir and $Folder variable
                string sFolder = ContentPath;
                if (string.IsNullOrEmpty(ContentPath))
                {
                    string sLocalPath = Environment.ExpandEnvironmentVariables("%TEMP%");
                    sFolder = Path.Combine(sLocalPath, SW.ContentID.ToString());
                }

                //prevent issue with 8.3 naming in PowerShell...
                string psPath = string.Format("Set-Location (gi \"{0}\").fullname -ErrorAction SilentlyContinue; $Folder = \"{0}\";", sFolder);
                int iExitCode = -1;

                //Run Install Script
                if (!string.IsNullOrEmpty(SW.PSInstall))
                {
                    try
                    {
                        downloadTask.Installing = true;
                        ProgressDetails(this.downloadTask, EventArgs.Empty);

                        var oResult = await _RunPSAsync(psPath + SW.PSPreInstall + ";" + SW.PSInstall + ";" + SW.PSPostInstall + ";$ExitCode", "", new TimeSpan(0, 60, 0));

                        try
                        {
                            iExitCode = ((int)oResult.Last().BaseObject);
                        }
                        catch { }

                        //Wait 1s to let the installer close completely...
                        System.Threading.Thread.Sleep(1100);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("PS ERROR: " + ex.Message);
                    }

                    //InstProgress(this, EventArgs.Empty);
                }

                //is installed ?
                if (CheckIsInstalled(false))
                {
                    ProgressDetails(downloadTask, EventArgs.Empty);
                    if (SendFeedback)
                        await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "true", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Ok...", RZRestAPIv2.CustomerID).ConfigureAwait(false); ;
                    return true;
                }
                else
                {
                    Console.WriteLine("WARNING: Product not detected after installation.");
                    //if (iExitCode != 0 &amp;&amp; iExitCode != 3010)
                    //{
                    //    if (SendFeedback)
                    //        RZRestAPI.Feedback(SW.ProductName, SW.ProductVersion, SW.Manufacturer, SW.Architecture, "false", sUserName, "Product not detected after installation.").ConfigureAwait(false); ;
                    //}

                    if (SendFeedback)
                        await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Product not detected after installation.", RZRestAPIv2.CustomerID).ConfigureAwait(false); ;

                    downloadTask.Error = true;
                    downloadTask.ErrorMessage = "WARNING: Product not detected after installation.";
                    downloadTask.Installed = false;
                    downloadTask.Installing = false;
                    ProgressDetails(downloadTask, EventArgs.Empty);
                    return false;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("ERROR: " + ex.Message);
                RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "ERROR: " + ex.Message, RZRestAPIv2.CustomerID);
                downloadTask.Error = true;
                downloadTask.ErrorMessage = "WARNING: Product not detected after installation.";
                downloadTask.Installed = false;
                downloadTask.Installing = false;
                bError = true;
            }

            //RZRestAPI.Feedback(SW.ProductName, SW.ProductVersion, (!bError).ToString(), "RZUpdate", "");
            ProgressDetails(this.downloadTask, EventArgs.Empty);
            return !bError;
        }

        private async Task&lt;bool&gt; _UnInstallAsync(bool Force = false)
        {
            //Check if Installer is already running
            if (downloadTask.Installing)
            {
                Thread.Sleep(1500);
                CheckIsInstalled(true);
                //ProgressDetails(this.downloadTask, EventArgs.Empty);
                return true;
            }

            downloadTask.Installing = true;


            bool bError = false;

            if (!await CheckDTPreReqAsync() &amp;&amp; !Force)
            {
                Console.WriteLine("Requirements not valid. Installation will not start.");
                downloadTask.Installing = false;
                downloadTask.Installed = false;
                downloadTask.Error = true;
                downloadTask.ErrorMessage = "Requirements not valid. Installation will not start.";
                ProgressDetails(this.downloadTask, EventArgs.Empty);

                if (SendFeedback)
                    await RZRestAPIv2.FeedbackAsync(SW.ProductName, SW.ProductVersion, SW.Manufacturer, "false", System.Reflection.Assembly.GetExecutingAssembly().GetName().Name, "Requirements not valid. Installation will not start.", RZRestAPIv2.CustomerID).ConfigureAwait(false); ;

                return false;
            }

            //Is Product already installed ?
            try
            {
                if (!Force)
                {
                    //Already installed ?
                    if (!CheckIsInstalled(false))
                    {
                        downloadTask.Installed = false;
                        downloadTask.Installing = false;
                        downloadTask.UnInstalled = true;
                        downloadTask.Error = false;
                        return true;
                    }
                }

                //Check if Installer is already running
                while (downloadTask.Installing)
                {
                    Thread.Sleep(1500);
                    if (!CheckIsInstalled(false))
                    {
                        downloadTask.Installed = false;
                        downloadTask.Installing = false;
                        downloadTask.UnInstalled = true;
                        downloadTask.Error = false;
                        return true;
                    }
                }

                downloadTask.Installing = true;

                int iExitCode = -1;

                //Run Install Script
                if (!string.IsNullOrEmpty(SW.PSUninstall))
                {
                    try
                    {
                        downloadTask.Installing = true;
                        ProgressDetails(this.downloadTask, EventArgs.Empty);

                        var oResult = _RunPS(SW.PSUninstall + ";$ExitCode", "", new TimeSpan(0, 30, 0));

                        try
                        {
                            iExitCode = ((int)oResult.Last().BaseObject);
                        }
                        catch { }

                        //Wait 500ms to let the installer close completely...
                        System.Threading.Thread.Sleep(550);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("PS ERROR: " + ex.Message);
                    }

                    downloadTask.Installing = false;
                    //InstProgress(this, EventArgs.Empty);
                }

                //is installed ?
                if (!CheckIsInstalled(false))
                {
                    downloadTask.Installed = false;
                    downloadTask.Installing = false;
                    downloadTask.UnInstalled = true;
                    downloadTask.Error = false;
                    //RZRestAPI.Feedback(SW.ProductName, SW.ProductVersion, "true", "RZUpdate", "Uninstalled...");
                    ProgressDetails(downloadTask, EventArgs.Empty);
                    return true;
                }
                else
                {
                    Console.WriteLine("WARNING: Product is still installed.");
                    downloadTask.Error = true;
                    downloadTask.ErrorMessage = "WARNING: Product is still installed.";
                    downloadTask.Installed = false;
                    downloadTask.Installing = false;
                    ProgressDetails(downloadTask, EventArgs.Empty);
                    return false;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("ERROR: " + ex.Message);
                downloadTask.Error = true;
                downloadTask.ErrorMessage = "WARNING: Product is still installed.";
                downloadTask.Installed = false;
                downloadTask.Installing = false;
                bError = true;
            }

            //RZRestAPI.Feedback(SW.ProductName, SW.ProductVersion, (!bError).ToString(), "RZUpdate", "");
            ProgressDetails(this.downloadTask, EventArgs.Empty);
            return !bError;

        }

        private void SWUpdate_ProgressDetails(object sender, EventArgs e)
        {
            if (sender.GetType() == typeof(DLStatus))
            {
                try
                {
                    DLStatus dlStatus = sender as DLStatus;
                    downloadTask.Installing = false;
                    downloadTask.Downloading = true;
                    downloadTask.DownloadedBytes = dlStatus.DownloadedBytes;
                    downloadTask.PercentDownloaded = dlStatus.PercentDownloaded;
                    downloadTask.TotalBytes = dlStatus.TotalBytes;
                }
                catch { }
            }
        }

    }
}</value>
  </data>
  <data name="Source" xml:space="preserve">
    <value>using RZUpdate;
using System;
using System.Reflection;
using System.Resources;
using System.Text;
using System.Threading;
using System.Net;
using System.Threading.Tasks;

namespace RZWrapper
{
    class RZWrapperClass
    {
        static int Main(string[] args)
        {
            string xmlSW = null;

            try
            {
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
                ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
                ServicePointManager.CheckCertificateRevocationList = false;
                Assembly _assembly = Assembly.GetExecutingAssembly();
                var stream = _assembly.GetManifestResourceStream("Resources.resx");
                var resourceData = new byte[] { };
                using (var rr = new ResourceReader(stream))
                {
                    var resourceType = "";
                    rr.GetResourceData("SW.json", out resourceType, out resourceData);
                }

                xmlSW = Encoding.Default.GetString(resourceData, 2, resourceData.Length - 2);

            }
            catch (Exception ex)
            {
                //Console.WriteLine("E1:" + ex.Message);
                //Thread.Sleep(1000);
            }

            try
            {
                RZUpdater oRZSW;
                if (!string.IsNullOrEmpty(xmlSW))
                {
                    string asAscii = xmlSW.Substring(xmlSW.IndexOf('{'));
                    oRZSW = new RZUpdater(asAscii);
                    oRZSW.SoftwareUpdate.SendFeedback = false;
                }
                else
                {
                    oRZSW = new RZUpdater();
                    oRZSW.SoftwareUpdate = new SWUpdate("RZRZRZ");
                }

                if (string.IsNullOrEmpty(oRZSW.SoftwareUpdate.SW.ProductName))
                {
                    Console.WriteLine("'RZRZRZ' is NOT available in RuckZuck...!");
                    return 1;
                }


                Console.WriteLine(oRZSW.SoftwareUpdate.SW.Manufacturer + " " + oRZSW.SoftwareUpdate.SW.ProductName + " " + oRZSW.SoftwareUpdate.SW.ProductVersion);
                Console.Write("Downloading...");
                if (oRZSW.SoftwareUpdate.SW.PreRequisites != null)
                {
                    foreach (string sPreReq in oRZSW.SoftwareUpdate.SW.PreRequisites)
                    {
                        if (!string.IsNullOrEmpty(sPreReq))
                        {
                            RZUpdater oRZSWPreReq = new RZUpdater();
                            oRZSWPreReq.SoftwareUpdate = new SWUpdate(sPreReq);
                            Console.WriteLine();
                            Console.Write("\tDownloading dependencies (" + oRZSWPreReq.SoftwareUpdate.SW.ShortName + ")...");
                            if (oRZSWPreReq.SoftwareUpdate.DownloadAsync().Result)
                            {
                                Console.WriteLine("... done.");
                                Console.Write("\tInstalling dependencies (" + oRZSWPreReq.SoftwareUpdate.SW.ShortName + ")...");
                                if (oRZSWPreReq.SoftwareUpdate.InstallAsync(false, true).Result)
                                {
                                    Console.WriteLine("... done.");
                                }
                                else
                                {
                                    Console.WriteLine("... Error. The installation failed.");
                                }
                            }
                        }
                    }
                }
                if (oRZSW.SoftwareUpdate.DownloadAsync().Result)
                {
                    Console.WriteLine("... done.");
                    Console.Write("Installing...");
                    if (oRZSW.SoftwareUpdate.InstallAsync(false, true).Result)
                    {

                        Console.WriteLine("... done.");
                        Thread.Sleep(2000);
                        return 0;
                    }
                    else
                    {
                        Console.WriteLine("... Error. The installation failed.");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
            }
            Thread.Sleep(3000);
            return 9;
        }
    }
}</value>
  </data>
</root>